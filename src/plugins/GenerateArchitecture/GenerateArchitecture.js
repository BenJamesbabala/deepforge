/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Sun Mar 20 2016 16:49:12 GMT-0500 (CDT).
 */

define([
    'TemplateCreator/TemplateCreator',
    //'TemplateCreator/Constants'
    'TemplateCreator/templates/Constants',
    'deepforge/layer-args',
    'deepforge/dimensionality',
    'underscore'
], function (
    PluginBase,
    Constants,
    LAYER_ARGS,
    dimensionality,
    _
) {
    'use strict';

    /**
     * Initializes a new instance of GenerateArchitecture.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin GenerateArchitecture.
     * @constructor
     */
    var GenerateArchitecture = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.generator = this;
    };

    // Prototypal inheritance from PluginBase.
    GenerateArchitecture.prototype = Object.create(PluginBase.prototype);
    GenerateArchitecture.prototype.constructor = GenerateArchitecture;

    /**
     * Gets the name of the GenerateArchitecture.
     * @returns {string} The name of the plugin.
     * @public
     */
    GenerateArchitecture.prototype.getName = function () {
        return 'GenerateArchitecture';
    };

    /**
     * Gets the semantic version (semver.org) of the GenerateArchitecture.
     * @returns {string} The version of the plugin.
     * @public
     */
    GenerateArchitecture.prototype.getVersion = function () {
        return '0.1.0';
    };

    GenerateArchitecture.prototype.createOutputFiles = function (tree) {
        var layers = tree[Constants.CHILDREN],
            result = {},
            template,
            snippet,
            code,
            args;

        code = [
            'require \'nn\'',
            '',
            'model = nn.Sequential()'
        ].join('\n');

        // Start with sequential (just one input)
        for (var i = 0; i < layers.length; i++) {
            if (layers[i][Constants.NEXT].length > 1) {
                // no support for 
                console.error('No support for parallel layers... yet');
                break;
            } else {
                // args
                args = GenerateArchitecture.createArgString(layers[i]);
                template = _.template('model:add(nn.{{= name }}' + args + ')');
                snippet = template(layers[i]);
                code += '\n' + snippet;
            }
        }

        result[tree.name + '.lua'] = code;
        return result;
    };

    GenerateArchitecture.createArgString = function (layer) {
        if (CreateLayerArgs[layer.name]) {
            return '(' + CreateLayerArgs[layer.name](layer).join(', ') + ')';
        }
        // fall back on default...
        return '(' + LAYER_ARGS[layer.name].map(arg => layer[arg.name]) + ')';
    };

    GenerateArchitecture.getDimArgs = function (layer) {
        var prev = layer[Constants.PREV][0],  // Assuming all inputs have the same dims
            fn = null;

        // Only return getDimArgs if 
        if (prev[Constants.PREV][0]) {
            fn = GenerateArchitecture.getDimArgs.bind(null, prev);
        }

        return [prev.name, prev, fn];
    };

    // Custom Layer Argument Generators
    // These return an array of argument values
    var CreateLayerArgs = {};

    CreateLayerArgs.Linear = function(layer) {
        var args = GenerateArchitecture.getDimArgs(layer),
            dims = dimensionality.apply(null, args);

        return [dims, layer.output];
    };

    CreateLayerArgs.Add = function(layer) {
        var args = GenerateArchitecture.getDimArgs(layer),
            dims = dimensionality.apply(null, args);

        return [dims, layer.isScalar];
    };

    return GenerateArchitecture;
});
